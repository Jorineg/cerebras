// 1602 - 1633 -> 31 cycles
// 1633 - 1660 -> 27 cycles
// 1660 - 1687 -> 27 cycles
// 1687 - 1714 -> 27 cycles




const simprint = @import_module("<simprint>");
// const tile_config = @import_module("<tile_config>");

param memcpy_params: comptime_struct;
param is_static_region: bool;
param steps: i16;

param send_e_col: color;
param send_w_col: color;
param send_n_col: color;
param send_s_col: color;

param recv_e_col: color;
param recv_w_col: color;
param recv_n_col: color;
param recv_s_col: color;

param row: i16;
param col: i16;

param width: i16;
param height: i16;

const receive_n_to_send = if (is_static_region) 1 else 4;

// Queue IDs
const send_color_oq_e = @get_output_queue(2);  // 0 is reserved
const send_color_oq_w = @get_output_queue(1);
const send_color_oq_n = @get_output_queue(3);
const send_color_oq_s = @get_output_queue(4);

const recv_color_iq_e = @get_input_queue(3);  // 0 and 1 are reserved
const recv_color_iq_w = @get_input_queue(2);
const recv_color_iq_n = @get_input_queue(4);
const recv_color_iq_s = @get_input_queue(5);

const is_corner = (col == 0 or col == width-1) and (row == 0 or row == height-1);

// const receive_data_task_e_id: data_task_id = if (@is_arch("wse3")) @get_data_task_id(recv_color_iq_e) else @get_data_task_id(recv_e_col);
// const receive_data_task_w_id: data_task_id = if (@is_arch("wse3")) @get_data_task_id(recv_color_iq_w) else @get_data_task_id(recv_w_col);
// const receive_data_task_n_id: data_task_id = if (@is_arch("wse3")) @get_data_task_id(recv_color_iq_n) else @get_data_task_id(recv_n_col);
// const receive_data_task_s_id: data_task_id = if (@is_arch("wse3")) @get_data_task_id(recv_color_iq_s) else @get_data_task_id(recv_s_col);

// Task ID used by a local task to unblock cmd stream
const exit_task_id: local_task_id = @get_local_task_id(9);

// memcpy module provides infrastructure for copying data
// and launching functions from the host
const sys_mod = @import_module("<memcpy/memcpy>", memcpy_params);

const rank: i16 = 1;
var weights = [rank+1]f32 {1.0, 0.5};
const zero: [1]f32 = [1]f32 {0.0};

const weight_zero: f32 = 1.0/3.0;
const weight_one: f32 = 1.0/6.0;

var dev_null: [1]f32;

var matrix: [1]f32 = [1]f32 {0.0};
var matrix_ptr: [*]f32 = &matrix;

// var recv_buffer_e: [1]f32;
// var recv_buffer_w: [1]f32;
// var recv_buffer_n: [1]f32;
// var recv_buffer_s: [1]f32;

var steps_executed: i16 = 0;
var wait_steps: u16 = 0;

var recv_counter: i16 = 0;

// DSDs for accessing weights and matrix
const weights_dsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{rank+1} -> weights[i+1] });
const matrix_dsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{1} -> matrix[0] });
const zero_dsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{1} -> zero[0] });
const dev_null_dsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{1} -> dev_null[0] });

const send_dsd_e = @get_dsd(fabout_dsd, .{ .fabric_color = send_e_col, .extent = 1, .output_queue = send_color_oq_e});
const send_dsd_w = @get_dsd(fabout_dsd, .{ .fabric_color = send_w_col, .extent = 1, .output_queue = send_color_oq_w});
const send_dsd_n = @get_dsd(fabout_dsd, .{ .fabric_color = send_n_col, .extent = 1, .output_queue = send_color_oq_n});
const send_dsd_s = @get_dsd(fabout_dsd, .{ .fabric_color = send_s_col, .extent = 1, .output_queue = send_color_oq_s});

const recv_dsd_e = @get_dsd(fabin_dsd, .{ .fabric_color = recv_e_col, .extent = 1, .input_queue = recv_color_iq_e});
const recv_dsd_w = @get_dsd(fabin_dsd, .{ .fabric_color = recv_w_col, .extent = 1, .input_queue = recv_color_iq_w});
const recv_dsd_n = @get_dsd(fabin_dsd, .{ .fabric_color = recv_n_col, .extent = 1, .input_queue = recv_color_iq_n});
const recv_dsd_s = @get_dsd(fabin_dsd, .{ .fabric_color = recv_s_col, .extent = 1, .input_queue = recv_color_iq_s});

// const recv_buffer_dsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{4} -> recv_buffer[i] });
// const recv_buffer_e_dsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{1} -> recv_buffer_e[0] });
// const recv_buffer_w_dsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{1} -> recv_buffer_w[0] });
// const recv_buffer_n_dsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{1} -> recv_buffer_n[0] });
// const recv_buffer_s_dsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{1} -> recv_buffer_s[0] });

// DSRs
const weights_dsr = @get_dsr(dsr_src1, 0);
const matrix_dsr = @get_dsr(dsr_src0, 1);
const matrix_dsr_src = @get_dsr(dsr_src1, 2);
const matrix_dsr_dest = @get_dsr(dsr_dest, 7);


const send_dsr_e = @get_dsr(dsr_dest, 3);
const send_dsr_w = @get_dsr(dsr_dest, 4);
const send_dsr_n = @get_dsr(dsr_dest, 5);
const send_dsr_s = @get_dsr(dsr_dest, 6);

const recv_dsr_e = @get_dsr(dsr_src1, 8);
const recv_dsr_w = @get_dsr(dsr_src1, 9);
const recv_dsr_n = @get_dsr(dsr_src1, 10);
const recv_dsr_s = @get_dsr(dsr_src1, 11);

// const receive_buffer_dsr = @get_dsr(dsr_src1, 8);

// const receive_buffer_e_dsr = @get_dsr(dsr_src1, 8);
// const receive_buffer_w_dsr = @get_dsr(dsr_src1, 9);
// const receive_buffer_n_dsr = @get_dsr(dsr_src1, 10);
// const receive_buffer_s_dsr = @get_dsr(dsr_src1, 11);



// function that initializes weights
// divide weights to not have to divide in the loop
// first weight is for center element, others are for neighbors
// so that sum of w[0] + 4*w[1] + 4*w[2] + ... + 4*w[rank] = 1
fn init_weights() void {
  var sum: f32 = 0.0;
  for (@range(i16, rank+1)) |i| {
    sum += if (i == 0) weights[i] else 4.0*weights[i];
  }
  for (@range(i16, rank+1)) |i| {
    weights[i] /= sum;
  }
}


// add received value to result
// fn receive_data_fn(data : f32) void {
//   // recv_buffer[recv_counter] = data;
//   recv_counter+=1;


//   if (recv_counter == receive_n_to_send) {    // 4 for non-static regions, 1 for static regions
//     // do computation
//     if(! is_static_region){
//       // @fmacs(matrix_dsr, matrix_dsr, weights_dsr, data);
//       // @fmacs(matrix_four_dsr, matrix_four_dsr, receive_buffer_dsr, weights[1]);

//       @fmacs(matrix_dsr, matrix_dsr, receive_buffer_e_dsr, weights[1]);
//       @fmacs(matrix_dsr, matrix_dsr, receive_buffer_w_dsr, weights[1]);
//       @fmacs(matrix_dsr, matrix_dsr, receive_buffer_n_dsr, weights[1]);
//       @fmacs(matrix_dsr, matrix_dsr, receive_buffer_s_dsr, weights[1]);
//     }

//     if (steps_executed >= steps) {
//       @activate(exit_task_id);
//     }else{
//       // add own value to result
//       send_to_neighbors();
//       recv_counter = 0;
//       steps_executed+=1;
//     }
//   }
// }

fn loop() void {
  // synchronized version
  for (@range(i16, steps)) |i| {
    send_to_neighbors();
    if (!is_static_region){
      @fmacs(matrix_dsr, matrix_dsr, recv_dsd_e, weight_one);
      @fmacs(matrix_dsr, matrix_dsr, recv_dsd_w, weight_one);
      @fmacs(matrix_dsr, matrix_dsr, recv_dsd_n, weight_one);
      @fmacs(matrix_dsr, matrix_dsr, recv_dsd_s, weight_one);
    }else{
      // receive and delete data
      border_receive_data();
    }
  }

  @activate(exit_task_id);
}


fn border_receive_data() void {
  if (col == 0) {
    @fmovs(dev_null_dsd, recv_dsd_e);
  }else if (col == width-1) {
    @fmovs(dev_null_dsd, recv_dsd_w);
  }else if (row == 0) {
    @fmovs(dev_null_dsd, recv_dsd_s);
  }else if (row == height-1) {
    @fmovs(dev_null_dsd, recv_dsd_n);
  }
}



fn send_to_neighbors() void {
  if(col < width-1 and row > 0 and row < height-1) {
    @fmovs(send_dsr_e, matrix_dsr_src);
  }
  if(col > 0 and row > 0 and row < height-1) {
    @fmovs(send_dsr_w, matrix_dsr_src);
  }
  if(row < height-1 and col > 0 and col < width-1) {
    @fmovs(send_dsr_s, matrix_dsr_src);
  }
  if(row > 0 and col > 0 and col < width-1) {
    @fmovs(send_dsr_n, matrix_dsr_src);
  }

  // add own value to result
  if(! is_static_region){
    @fmuls(matrix_dsr, matrix_dsr, weight_zero);
  }
}

// Call gemv function and send/ receive partial result y
fn compute() void {
  init_weights();
  if (is_corner) {
    @activate(exit_task_id);
  }else{
    loop();
  }
}


task exit_task() void {
  sys_mod.unblock_cmd_stream();
}

comptime {
  // When exit_task_id is activated, exit_task will execute
  @bind_local_task(exit_task, exit_task_id);

  // tile_config.task_priority.set_task_priority(receive_data_task_e_id);
  // tile_config.task_priority.set_task_priority(receive_data_task_w_id);
  // tile_config.task_priority.set_task_priority(receive_data_task_n_id);
  // tile_config.task_priority.set_task_priority(receive_data_task_s_id);   

  // bind same receive_data task to all receive data task ids
  // @bind_data_task(receive_data_e, receive_data_task_e_id);
  // @bind_data_task(receive_data_w, receive_data_task_w_id);
  // @bind_data_task(receive_data_n, receive_data_task_n_id);
  // @bind_data_task(receive_data_s, receive_data_task_s_id);

  // load DSDs to DSRs
  @load_to_dsr(weights_dsr, weights_dsd);
  @load_to_dsr(matrix_dsr, matrix_dsd);
  @load_to_dsr(matrix_dsr_src, matrix_dsd);
  @load_to_dsr(matrix_dsr_dest, matrix_dsd);
  
  @load_to_dsr(send_dsr_e, send_dsd_e);
  @load_to_dsr(send_dsr_w, send_dsd_w);
  @load_to_dsr(send_dsr_n, send_dsd_n);
  @load_to_dsr(send_dsr_s, send_dsd_s);

  @load_to_dsr(recv_dsr_e, recv_dsd_e);
  @load_to_dsr(recv_dsr_w, recv_dsd_w);
  @load_to_dsr(recv_dsr_n, recv_dsd_n);
  @load_to_dsr(recv_dsr_s, recv_dsd_s);

  // @load_to_dsr(receive_buffer_dsr, recv_buffer_dsd);

  // @load_to_dsr(receive_buffer_e_dsr, recv_buffer_e_dsd);
  // @load_to_dsr(receive_buffer_w_dsr, recv_buffer_w_dsd);
  // @load_to_dsr(receive_buffer_n_dsr, recv_buffer_n_dsd);
  // @load_to_dsr(receive_buffer_s_dsr, recv_buffer_s_dsd);


  // On WSE-3, we must explicitly initialize input and output queues
  if (@is_arch("wse3")) {
    @initialize_queue(send_color_oq_e, .{ .color = send_e_col });
    @initialize_queue(send_color_oq_w, .{ .color = send_w_col });
    @initialize_queue(send_color_oq_n, .{ .color = send_n_col });
    @initialize_queue(send_color_oq_s, .{ .color = send_s_col });

    @initialize_queue(recv_color_iq_e, .{ .color = recv_e_col });
    @initialize_queue(recv_color_iq_w, .{ .color = recv_w_col });
    @initialize_queue(recv_color_iq_n, .{ .color = recv_n_col });
    @initialize_queue(recv_color_iq_s, .{ .color = recv_s_col });
  }

  @export_symbol(matrix_ptr, "matrix");
  @export_symbol(compute);
}