// params
param memcpy_params: comptime_struct;
param is_border: bool;

param send_e_col: color;
param send_w_col: color;
param send_n_col: color;
param send_s_col: color;

param recv_e_col: color;
param recv_w_col: color;
param recv_n_col: color;
param recv_s_col: color;

param num_iterations: i16;
param row: i16;
param col: i16;
param pe_width: i16;
param pe_height: i16;
param rank: i16;
param tile_width: i16;
param tile_height: i16;

// consts
const sys_mod = @import_module("<memcpy/memcpy>", memcpy_params);

// Queue IDs
const send_color_oq_e = @get_output_queue(1);  // 0 is reserved
const send_color_oq_w = @get_output_queue(2);
const send_color_oq_n = @get_output_queue(3);
const send_color_oq_s = @get_output_queue(4);

const recv_color_iq_e = @get_input_queue(2);  // 0 and 1 are reserved
const recv_color_iq_w = @get_input_queue(3);
const recv_color_iq_n = @get_input_queue(4);
const recv_color_iq_s = @get_input_queue(5);

const is_corner = (col == 0 or col == width-1) and (row == 0 or row == height-1);
const exit_task_id: local_task_id = @get_local_task_id(9);

var weights: [rank+1]f32;
var own_values: [tile_height, tile_width]f32;
var buffer: [tile_height + 2*rank, tile_width + 2*rank]f32;

// pointers
const weights_ptr = &weights;
const own_values_ptr = &own_values;

// mem DSDs
const all_buffer_dsd = @get_dsd(mem4d_dsd, .{ .tensor_access = |i, j|{tile_height + 2*rank, tile_width + 2*rank} -> buffer[i, j] });
const buffer_center_dsd = @get_dsd(mem4d_dsd, .{ .tensor_access = |i, j|{tile_height, tile_width} -> buffer[rank + i, rank + j] });
const own_values_dsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{tile_height*tile_width} -> own_values[i] });

const own_values_send_north_dsd = @get_dsd(mem4d_dsd, .{ .tensor_access = |i, j|{rank, tile_width} -> own_values[i, j] });
const own_values_send_south_dsd = @get_dsd(mem4d_dsd, .{ .tensor_access = |i, j|{rank, tile_width} -> own_values[tile_height - rank + i, j] });
const own_values_send_west_dsd = @get_dsd(mem4d_dsd, .{ .tensor_access = |i, j|{tile_height, rank} -> own_values[i, j] });
const own_values_send_east_dsd = @get_dsd(mem4d_dsd, .{ .tensor_access = |i, j|{tile_height, rank} -> own_values[i, tile_width - rank + j] });

const buffer_recv_north_dsd = @get_dsd(mem4d_dsd, .{ .tensor_access = |i, j|{rank, tile_width} -> buffer[i, rank + j] });
const buffer_recv_south_dsd = @get_dsd(mem4d_dsd, .{ .tensor_access = |i, j|{rank, tile_width} -> buffer[tile_height + rank + i, rank + j] });
const buffer_recv_west_dsd = @get_dsd(mem4d_dsd, .{ .tensor_access = |i, j|{tile_height, rank} -> buffer[rank + i, j] });
const buffer_recv_east_dsd = @get_dsd(mem4d_dsd, .{ .tensor_access = |i, j|{tile_height, rank} -> buffer[rank + i, tile_width + rank + j] });

var buffer_shift_up_center_dsd_array: [rank]mem4d_dsd;
var buffer_shift_down_center_dsd_array: [rank]mem4d_dsd;
var buffer_shift_left_center_dsd_array: [rank]mem4d_dsd;
var buffer_shift_right_center_dsd_array: [rank]mem4d_dsd;


// communication DSDs
const send_north_dsd = @get_dsd(fabout_dsd, .{ .fabric_color = send_n_col, .extent = tile_width*rank, .output_queue = send_color_oq_n });
const send_south_dsd = @get_dsd(fabout_dsd, .{ .fabric_color = send_s_col, .extent = tile_width*rank, .output_queue = send_color_oq_s });
const send_west_dsd = @get_dsd(fabout_dsd, .{ .fabric_color = send_w_col, .extent = tile_height*rank, .output_queue = send_color_oq_w });
const send_east_dsd = @get_dsd(fabout_dsd, .{ .fabric_color = send_e_col, .extent = tile_height*rank, .output_queue = send_color_oq_e });

const recv_north_dsd = @get_dsd(fabin_dsd, .{ .fabric_color = recv_n_col, .extent = tile_width*rank, .input_queue = recv_color_iq_n });
const recv_south_dsd = @get_dsd(fabin_dsd, .{ .fabric_color = recv_s_col, .extent = tile_width*rank, .input_queue = recv_color_iq_s });
const recv_west_dsd = @get_dsd(fabin_dsd, .{ .fabric_color = recv_w_col, .extent = tile_height*rank, .input_queue = recv_color_iq_w });
const recv_east_dsd = @get_dsd(fabin_dsd, .{ .fabric_color = recv_e_col, .extent = tile_height*rank, .input_queue = recv_color_iq_e });



fn init_buffer_shift_dsd_arrays() void {
  for (0..rank) |k| {
    var shift = k+1;
    buffer_shift_up_center_dsd_array[k] = @get_dsd(mem4d_dsd, .{ .tensor_access = |i, j|{tile_height, tile_width} -> buffer[rank - shift + i, rank + j] });
    buffer_shift_down_center_dsd_array[k] = @get_dsd(mem4d_dsd, .{ .tensor_access = |i, j|{tile_height, tile_width} -> buffer[rank + shift + i, rank + j] });
    buffer_shift_left_center_dsd_array[k] = @get_dsd(mem4d_dsd, .{ .tensor_access = |i, j|{tile_height, tile_width} -> buffer[rank + i, rank - shift + j] });
    buffer_shift_right_center_dsd_array[k] = @get_dsd(mem4d_dsd, .{ .tensor_access = |i, j|{tile_height, tile_width} -> buffer[rank + i, rank + shift + j] });
  }
}


// function that initializes weights
// divide weights to not have to divide in the loop
// first weight is for center element, others are for neighbors
// so that sum of w[0] + 4*w[1] + 4*w[2] + ... + 4*w[rank] = 1
fn init_weights() void {
  var sum: f32 = 0.0;
  for (@range(i16, rank+1)) |i| {
    sum += if (i == 0) weights[i] else 4.0*weights[i];
  }
  for (@range(i16, rank+1)) |i| {
    weights[i] /= sum;
  }
}


fn loop() void {
  // copy own_values to buffer
  @fmovs(own_values_dsd, buffer_center_dsd);

  // send cropped own_values to neighbors
  send_to_neighbors();

  //receive data from all directions and store in buffer
  receive_from_neighbours();

  // multiply own_values with weights[0]
  @fmuls(own_values_dsd, own_values_dsd, weights[0]);

  for (1..rank) |i| {
    const weight: f32 = if (i == 1) weights[i] else weights[i]/weights[i-1];
    
    // multiply buffer with weight
    @fmuls(all_buffer_dsd, all_buffer_dsd, weight);

    // add buffer shifted up/down/left/right by i cells to own_values
    @fadds(own_values_dsd, own_values_dsd, buffer_shift_up_center_dsd_array[i-1]);
    @fadds(own_values_dsd, own_values_dsd, buffer_shift_down_center_dsd_array[i-1]);
    @fadds(own_values_dsd, own_values_dsd, buffer_shift_left_center_dsd_array[i-1]);
    @fadds(own_values_dsd, own_values_dsd, buffer_shift_right_center_dsd_array[i-1]);
  }
}


fn send_to_neighbors() void {
  // send west
  if(!col == 0){
    @fmovs(send_west_dsd, own_values_send_west_dsd);
  }
  //send east
  if(!col == pe_width-1){
    @fmovs(send_east_dsd, own_values_send_east_dsd);
  }
  // send north
  if(!col == 0){
    @fmovs(send_north_dsd, own_values_send_north_dsd);
  }
  // send south
  if(!col == pe_height-1){
    @fmovs(send_south_dsd, own_values_send_south_dsd);
  }
}

fn receive_from_neighbors() void {
  // receive west
  if(!col == 0){
    @fmovs(buffer_recv_west_dsd, recv_west_dsd);
  }
  //send east
  if(!col == pe_width-1){
    @fmovs(buffer_recv_east_dsd, recv_east_dsd);
  }
  // send north
  if(!col == 0){
    @fmovs(buffer_recv_north_dsd, recv_north_dsd);
  }
  // send south
  if(!col == pe_height-1){
    @fmovs(buffer_recv_south_dsd, recv_south_dsd);
  }
}


fn compute() void {
  init_weights();
  for (0..num_iterations) |i| {
    loop();
  }
  @activate(exit_task_id);
}


task exit_task() void {
  sys_mod.unblock_cmd_stream();
}

comptime {
  // When exit_task_id is activated, exit_task will execute
  @bind_local_task(exit_task, exit_task_id);

  // On WSE-3, we must explicitly initialize input and output queues
  if (@is_arch("wse3")) {
    @initialize_queue(send_color_oq_e, .{ .color = send_e_col });
    @initialize_queue(send_color_oq_w, .{ .color = send_w_col });
    @initialize_queue(send_color_oq_n, .{ .color = send_n_col });
    @initialize_queue(send_color_oq_s, .{ .color = send_s_col });

    @initialize_queue(recv_color_iq_e, .{ .color = recv_e_col });
    @initialize_queue(recv_color_iq_w, .{ .color = recv_w_col });
    @initialize_queue(recv_color_iq_n, .{ .color = recv_n_col });
    @initialize_queue(recv_color_iq_s, .{ .color = recv_s_col });
  }else{

    // must also be initialized on WSE-2 manually if using dsrs
    // not documented !!!
    @initialize_queue(recv_color_iq_e, .{ .color = recv_e_col });
    @initialize_queue(recv_color_iq_w, .{ .color = recv_w_col });
    @initialize_queue(recv_color_iq_n, .{ .color = recv_n_col });
    @initialize_queue(recv_color_iq_s, .{ .color = recv_s_col });
  }

  @export_symbol(own_values_ptr, "values");
  @export_symbol(weights_ptr, "weights");
  @export_symbol(compute);
  
}