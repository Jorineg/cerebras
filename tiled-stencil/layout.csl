param w: i16;             // width of matrix to perform stencil on
param h: i16;             // height of matrix to perform stencil on
param tile_width: i16;   // width of each tile in x direction
param tile_height: i16;   // height of each tile in y direction
param rank: i16;          // rank of the stencil
param num_iterations: i16;         // number of iterations to run the stencil

// rank must be smaller or equal to the min(tile_width, tile_height)
// acutal number of PEs is given by w/tile_width * h/tile_height
// w must be a multiple of tile_width and h must be a multiple of tile_height

const num_pe_x = w / tile_width;
const num_pe_y = h / tile_height;

// Colors
const e_to_w_col_1: color = @get_color(1);
const e_to_w_col_2: color = @get_color(2);
const w_to_e_col_1: color = @get_color(3);
const w_to_e_col_2: color = @get_color(4);
const n_to_s_col_1: color = @get_color(5);
const n_to_s_col_2: color = @get_color(6);
const s_to_n_col_1: color = @get_color(7);
const s_to_n_col_2: color = @get_color(8);


const memcpy = @import_module("<memcpy/get_params>", .{
  .width = num_pe_x,
  .height = num_pe_y,
});

fn validate_parameters() void {
  @comptime_assert(w % tile_width == 0, "w must be a multiple of tile_width");
  @comptime_assert(h % tile_height == 0, "h must be a multiple of tile_height");
  @comptime_assert(rank <= tile_width, "rank must be smaller or equal to tile_width");
  @comptime_assert(rank <= tile_height, "rank must be smaller or equal to tile_height");
}

layout {
  validate_parameters();

  // PE coordinates are (column, row)
  @set_rectangle(num_pe_x, num_pe_y);

  for (@range(i16, num_pe_x)) |col| {
    for (@range(i16, num_pe_y)) |row| {
      const is_static_region: bool = col<1 or row<1 or col>=num_pe_x-1 or row>=num_pe_y-1;

      var basic_params = .{
        .memcpy_params = memcpy.get_params(col),
        .is_border = is_static_region,
        .num_iterations = num_iterations,
        .row = row,
        .col = col,
        .pe_width = num_pe_x,
        .pe_height = num_pe_y,
        .rank = rank,
        .tile_width = tile_width,
        .tile_height = tile_height,
      };

      var color_params = .{
        .send_e_col = w_to_e_col_1,
        .send_w_col = e_to_w_col_1,
        .send_n_col = s_to_n_col_1,
        .send_s_col = n_to_s_col_1,
        .recv_e_col = e_to_w_col_2,
        .recv_w_col = w_to_e_col_2,
        .recv_n_col = n_to_s_col_2,
        .recv_s_col = s_to_n_col_2,
      };

      // checkerboard pattern
      if(col%2 == row%2){
        var params = @concat_structs(basic_params, color_params);
        @set_tile_code(col, row, "pe_program.csl", params);

        @set_color_config(col, row, e_to_w_col_1, .{.routes = .{ .rx = .{RAMP}, .tx = .{WEST} }});
        @set_color_config(col, row, w_to_e_col_1, .{.routes = .{ .rx = .{RAMP}, .tx = .{EAST} }});
        @set_color_config(col, row, n_to_s_col_1, .{.routes = .{ .rx = .{RAMP}, .tx = .{SOUTH} }});
        @set_color_config(col, row, s_to_n_col_1, .{.routes = .{ .rx = .{RAMP}, .tx = .{NORTH} }});

        @set_color_config(col, row, e_to_w_col_2, .{.routes = .{ .rx = .{EAST}, .tx = .{RAMP} }});
        @set_color_config(col, row, w_to_e_col_2, .{.routes = .{ .rx = .{WEST}, .tx = .{RAMP} }});
        @set_color_config(col, row, n_to_s_col_2, .{.routes = .{ .rx = .{NORTH}, .tx = .{RAMP} }});
        @set_color_config(col, row, s_to_n_col_2, .{.routes = .{ .rx = .{SOUTH}, .tx = .{RAMP} }});

      }else{
        color_params = .{
          .send_e_col = w_to_e_col_2,
          .send_w_col = e_to_w_col_2,
          .send_n_col = s_to_n_col_2,
          .send_s_col = n_to_s_col_2,
          .recv_e_col = w_to_e_col_1,
          .recv_w_col = e_to_w_col_1,
          .recv_n_col = s_to_n_col_1,
          .recv_s_col = n_to_s_col_1,
        };

        var params = @concat_structs(basic_params, color_params);
        @set_tile_code(col, row, "pe_program.csl", params);

        @set_color_config(col, row, e_to_w_col_1, .{.routes = .{ .rx = .{WEST}, .tx = .{RAMP} }});
        @set_color_config(col, row, w_to_e_col_1, .{.routes = .{ .rx = .{EAST}, .tx = .{RAMP} }});
        @set_color_config(col, row, n_to_s_col_1, .{.routes = .{ .rx = .{SOUTH}, .tx = .{RAMP} }});
        @set_color_config(col, row, s_to_n_col_1, .{.routes = .{ .rx = .{NORTH}, .tx = .{RAMP} }});

        @set_color_config(col, row, e_to_w_col_2, .{.routes = .{ .rx = .{RAMP}, .tx = .{WEST} }});
        @set_color_config(col, row, w_to_e_col_2, .{.routes = .{ .rx = .{RAMP}, .tx = .{EAST} }});
        @set_color_config(col, row, n_to_s_col_2, .{.routes = .{ .rx = .{RAMP}, .tx = .{SOUTH} }});
        @set_color_config(col, row, s_to_n_col_2, .{.routes = .{ .rx = .{RAMP}, .tx = .{NORTH} }});
      }
    }
  }

  // export symbol names
  @export_name("values", *[tile_width, tile_height]f32, true);
  @export_name("weights", *[rank+1]f32, true);
  @export_name("compute", fn()void);
}