// cycle count evaluation (6x6 tile, radius=1 -> 4*36 fmacs + 36 fmuls)
// 1.  3792->4199 = 407
// 2.  4199->4640 = 441
// 3.  4640->5081 = 441
// 4.  5081->5522 = 441

// 505 cycles per iteration on wse3


// 1 cycles per fmacs for up down shifted
// 1 cycle per fmacs for left right shifted
// 10 cycles for starting fmacs (probaply moving dsd to dsr) -> 50 cycles per iteration. Can be saved by using dsrs from the start.
// 1 cycle for fmuls


// communication
// 6040 -> 6184 = 144 cycles
// Theoretical:
// send and receive values: 6*4*2=48 values and 48 cycles

// fuls: 36
// fmacs: 4*36*1 = 144
// communication: 144
// other??: 50
// total: 36+144+144+50 = 374

// lower bound calculation: 36*5/s = 180/s


// const simprint = @import_module("<simprint>");

// params
param memcpy_params: comptime_struct;
param is_border: bool;

param send_e_col: color;
param send_w_col: color;
param send_n_col: color;
param send_s_col: color;

param recv_e_col: color;
param recv_w_col: color;
param recv_n_col: color;
param recv_s_col: color;

param num_iterations: i16;
param row: i16;
param col: i16;
param pe_width: i16;
param pe_height: i16;
param tile_width: i16;
param tile_height: i16;

// consts
const radius: i16 = 1;
const sys_mod = @import_module("<memcpy/memcpy>", memcpy_params);

// Queue IDs
const send_color_oq_e = @get_output_queue(0);  // 0 is reserved
const send_color_oq_w = @get_output_queue(1);
const send_color_oq_n = @get_output_queue(2);
const send_color_oq_s = @get_output_queue(3);

const recv_color_iq_e = @get_input_queue(4);  // 0 and 1 are reserved
const recv_color_iq_w = @get_input_queue(5);
const recv_color_iq_n = @get_input_queue(6);
const recv_color_iq_s = @get_input_queue(7);

const is_corner = (col == 0 or col == pe_width-1) and (row == 0 or row == pe_height-1);
const exit_task_id: local_task_id = @get_local_task_id(9);
const receive_east_task_id: local_task_id = @get_local_task_id(10);
const receive_west_task_id: local_task_id = @get_local_task_id(11);
const receive_north_task_id: local_task_id = @get_local_task_id(12);
const receive_south_task_id: local_task_id = @get_local_task_id(13);
const send_west_task_id: local_task_id = @get_local_task_id(14);
const send_east_task_id: local_task_id = @get_local_task_id(15);
const send_north_task_id: local_task_id = @get_local_task_id(16);
const send_south_task_id: local_task_id = @get_local_task_id(17);

const loop_task_id: local_task_id = @get_local_task_id(18);

const buffer_width = tile_width + 2*radius + 1; // last column is not used. only for memory alignment.
const buffer_height = tile_height + 2*radius;

var receive_count: i16 = 0;
var send_count: i16 = 0;
var iteration_count: i16 = 0;
var weights: [radius+1]f32;
var own_values: [buffer_height, buffer_width]f32 linksection(".own_values");
var buffer: [buffer_height, buffer_width]f32 linksection(".buffer");

// pointers
var weights_ptr = &weights;
var own_values_ptr = &own_values;
var buffer_ptr = &buffer;

// mem DSDs
// const all_buffer_dsd = @get_dsd(mem4d_dsd, .{ .tensor_access = |i, j|{buffer_height, buffer_width} -> buffer[i, j] });
const buffer_center_dsd = @get_dsd(mem4d_dsd, .{ .tensor_access = |i, j|{tile_height, tile_width} -> buffer[radius + i, radius + j] });
const own_values_dsd = @get_dsd(mem4d_dsd, .{ .tensor_access = |i, j|{tile_height, tile_width} -> own_values[radius + i, radius + j] });

const own_values_send_north_dsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{tile_width} -> own_values[radius, radius + i] });
const own_values_send_south_dsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{tile_width} -> own_values[tile_height, radius + i] });
const own_values_send_west_dsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{tile_height} -> own_values[radius + i, radius] });
const own_values_send_east_dsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{tile_height} -> own_values[radius + i, tile_width] });

const buffer_recv_north_dsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{tile_width} -> buffer[0, radius + i] });
const buffer_recv_south_dsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{tile_width} -> buffer[tile_height + radius, radius + i] });
const buffer_recv_west_dsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{tile_height} -> buffer[radius + i, 0] });
const buffer_recv_east_dsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{tile_height} -> buffer[radius + i, tile_width + radius] });

const up_shift_dsd = @get_dsd(mem4d_dsd, .{ .tensor_access = |i, j|{tile_height, tile_width} -> buffer[radius + i - 1, radius + j] });
const down_shift_dsd = @get_dsd(mem4d_dsd, .{ .tensor_access = |i, j|{tile_height, tile_width} -> buffer[radius + i + 1, radius + j] });
const left_shift_dsd = @get_dsd(mem4d_dsd, .{ .tensor_access = |i, j|{tile_height, tile_width} -> buffer[radius + i, radius + j - 1] });
const right_shift_dsd = @get_dsd(mem4d_dsd, .{ .tensor_access = |i, j|{tile_height, tile_width} -> buffer[radius + i, radius + j + 1] });

// communication DSDs
const send_north_dsd = @get_dsd(fabout_dsd, .{ .fabric_color = send_n_col, .extent = tile_width*radius, .output_queue = send_color_oq_n });
const send_south_dsd = @get_dsd(fabout_dsd, .{ .fabric_color = send_s_col, .extent = tile_width*radius, .output_queue = send_color_oq_s });
const send_west_dsd = @get_dsd(fabout_dsd, .{ .fabric_color = send_w_col, .extent = tile_height*radius, .output_queue = send_color_oq_w });
const send_east_dsd = @get_dsd(fabout_dsd, .{ .fabric_color = send_e_col, .extent = tile_height*radius, .output_queue = send_color_oq_e });

const recv_north_dsd = @get_dsd(fabin_dsd, .{ .fabric_color = recv_n_col, .extent = tile_width*radius, .input_queue = recv_color_iq_n });
const recv_south_dsd = @get_dsd(fabin_dsd, .{ .fabric_color = recv_s_col, .extent = tile_width*radius, .input_queue = recv_color_iq_s });
const recv_west_dsd = @get_dsd(fabin_dsd, .{ .fabric_color = recv_w_col, .extent = tile_height*radius, .input_queue = recv_color_iq_w });
const recv_east_dsd = @get_dsd(fabin_dsd, .{ .fabric_color = recv_e_col, .extent = tile_height*radius, .input_queue = recv_color_iq_e });

// instuctions
// @fmovs(buffer_center_dsd, own_values_dsd);
// @fmacs(own_values_dsd, own_values_dsd, DIRECTION_shift_dsd, weight);
// @fmovs(send_DIRECTION_dsd, own_values_send_DIRECTION_dsd, .{.async= true, .activate=send_DIRECTION_task});
// @fmovs(buffer_recv_DIRECTION_dsd, recv_DIRECTION_dsd, .{.async=true, .activate=receive_DIRECTION_task});

// dsrs
// dest dsrs
const own_values_dsr_dest_1 = @get_dsr(dsr_dest, 1);
const own_values_dsr_dest_2 = @get_dsr(dsr_dest, 2);
const own_values_dsr_dest_3 = @get_dsr(dsr_dest, 3);
const own_values_dsr_dest_4 = @get_dsr(dsr_dest, 4);

const send_north_dsr_dest_5 = @get_dsr(dsr_dest, 5);
const send_south_dsr_dest_6 = @get_dsr(dsr_dest, 6);
const send_west_dsr_dest_7 = @get_dsr(dsr_dest, 7);
const send_east_dsr_dest_8 = @get_dsr(dsr_dest, 8);
const buffer_recv_north_dsr_dest_9 = @get_dsr(dsr_dest, 9);
const buffer_recv_south_dsr_dest_10 = @get_dsr(dsr_dest, 10);
const buffer_recv_west_dsr_dest_11 = @get_dsr(dsr_dest, 11);
const buffer_recv_east_dsr_dest_12 = @get_dsr(dsr_dest, 12);

const buffer_center_dsr_dest_13 = @get_dsr(dsr_dest, 13);

// src0 dsrs
const own_values_dsr_src0_1 = @get_dsr(dsr_src0, 1);
const own_values_dsr_src0_2 = @get_dsr(dsr_src0, 2);
const own_values_dsr_src0_3 = @get_dsr(dsr_src0, 3);
const own_values_dsr_src0_4 = @get_dsr(dsr_src0, 4);


// src1 dsrs
const shift_up_dsr_src1_1 = @get_dsr(dsr_src1, 1);
const shift_down_dsr_src1_2 = @get_dsr(dsr_src1, 2);
const shift_left_dsr_src1_3 = @get_dsr(dsr_src1, 3);
const shift_right_dsr_src1_4 = @get_dsr(dsr_src1, 4);

const own_values_send_north_dsr_src1_5 = @get_dsr(dsr_src1, 5);
const own_values_send_south_dsr_src1_6 = @get_dsr(dsr_src1, 6);
const own_values_send_west_dsr_src1_7 = @get_dsr(dsr_src1, 7);
const own_values_send_east_dsr_src1_8 = @get_dsr(dsr_src1, 8);
const recv_north_dsr_src1_9 = @get_dsr(dsr_src1, 9);
const recv_south_dsr_src1_10 = @get_dsr(dsr_src1, 10);
const recv_west_dsr_src1_11 = @get_dsr(dsr_src1, 11);
const recv_east_dsr_src1_12 = @get_dsr(dsr_src1, 12);

const own_values_dsr_src1_13 = @get_dsr(dsr_src1, 13);

var _wait_var: i16 = 0;


// function that initializes weights
// divide weights to not have to divide in the loop
// first weight is for center element, others are for neighbors
// so that sum of w[0] + 4*w[1] + 4*w[2] + ... + 4*w[radius] = 1
fn init_weights() void {
  var sum: f32 = 0.0;
  for (@range(i16, radius+1)) |i| {
    sum += if (i == 0) weights[i] else 4.0*weights[i];
  }
  for (@range(i16, radius+1)) |i| {
    weights[i] /= sum;
  }
}

task loop_task() void {

  // simprint.fmt_with_coords("loop task begin", .{});

  @block(loop_task_id);

  // copy own_values to buffer
  @fmovs(buffer_center_dsr_dest_13, own_values_dsr_src1_13);

  // send cropped own_values to neighbors
  send_to_neighbors();

  //receive data from all directions and store in buffer
  receive_from_neighbors();
}

fn send_task() void {
  send_count += 1;

  var max_send: i16 = 4;
  if (is_corner) {
    max_send = 2;
  } else if (is_border) {
    max_send = 3;
  }
  
  if (send_count < max_send) {
    return;
  }
  send_count = 0;
  @unblock(loop_task_id);
}

task send_west_task() void {
  send_task();
}

task send_east_task() void {
  send_task();
}

task send_north_task() void {
  send_task();
}

task send_south_task() void {
  send_task();
}

task receive_east_task() void {
  receive_task();
}

task receive_west_task() void {
  receive_task();
}

task receive_north_task() void {
  receive_task();
}

task receive_south_task() void {
  receive_task();
}

fn receive_task() void {
  receive_count += 1;
  var max_receive: i16 = 4;
  
  if (is_corner) {
    max_receive = 2;
  } else if (is_border) {
    max_receive = 3;
  }

  if (receive_count < max_receive) {
    return;
  }
  receive_count = 0;

  // if is_border is true: return
  if (!is_border) {

    // multiply own_values with weights[0]
    @fmuls(own_values_dsr_dest_1, own_values_dsr_src0_1, weights[0]);

    // const weight: f32 = if (i == 1) weights[i] else weights[i]/weights[i-1];
    const weight: f32 = weights[1];
    
    // multiply buffer with weight
    // @fmuls(all_buffer_dsd, all_buffer_dsd, weight);

    
    // add shifted dsds to own_values
    // @fadds(own_values_dsd, own_values_dsd, up_shift_dsd);
    // _wait_var += 1;
    // @fadds(own_values_dsd, own_values_dsd, down_shift_dsd);
    // _wait_var += 1;
    // @fadds(own_values_dsd, own_values_dsd, left_shift_dsd);
    // _wait_var += 1;
    // @fadds(own_values_dsd, own_values_dsd, right_shift_dsd);
    // _wait_var += 1;

    // add multiple of dsd to own_values with fused multiply add
    @fmacs(own_values_dsr_dest_1, own_values_dsr_src0_1, shift_up_dsr_src1_1, weight);
    _wait_var += 1;  // wait for 1 cycle
    @fmacs(own_values_dsr_dest_2, own_values_dsr_src0_2, shift_down_dsr_src1_2, weight);
    _wait_var += 1;
    @fmacs(own_values_dsr_dest_3, own_values_dsr_src0_3, shift_left_dsr_src1_3, weight);
    _wait_var += 1;
    @fmacs(own_values_dsr_dest_4, own_values_dsr_src0_4, shift_right_dsr_src1_4, weight);
    _wait_var += 1;
  }

  iteration_count += 1;
  if (iteration_count < num_iterations) {
    @activate(loop_task_id);
  }else{
    @activate(exit_task_id);
  }
}


fn send_to_neighbors() void {
  // send west
  if(col != 0){
    @fmovs(send_west_dsr_dest_7, own_values_send_west_dsr_src1_7, .{.async=true, .activate=send_west_task});
  }
  //send east
  if(col != pe_width-1){
    @fmovs(send_east_dsr_dest_8, own_values_send_east_dsr_src1_8, .{.async= true, .activate=send_east_task});
  }
  // send north
  if(row != 0){
    @fmovs(send_north_dsr_dest_5, own_values_send_north_dsr_src1_5, .{.async= true, .activate=send_north_task});
  }
  // send south
  if(row != pe_height-1){
    @fmovs(send_south_dsr_dest_6, own_values_send_south_dsr_src1_6, .{.async= true, .activate=send_south_task});
  }
}

fn receive_from_neighbors() void {
  // receive west
  if(col != 0){
    @fmovs(buffer_recv_west_dsr_dest_11, recv_west_dsr_src1_11, .{.async=true, .activate=receive_west_task});
  }
  //receive east
  if(col != pe_width-1){
    @fmovs(buffer_recv_east_dsr_dest_12, recv_east_dsr_src1_12, .{.async=true, .activate=receive_east_task});
  }
  // receive north
  if(row != 0){
    @fmovs(buffer_recv_north_dsr_dest_9, recv_north_dsr_src1_9, .{.async=true, .activate=receive_north_task});
  }
  // receive south
  if(row != pe_height-1){
    @fmovs(buffer_recv_south_dsr_dest_10, recv_south_dsr_src1_10, .{.async=true, .activate=receive_south_task});
  }
}


fn compute() void {
  init_weights();
  @activate(loop_task_id);
}


task exit_task() void {
  // simprint.fmt_with_coords("exit task begin", .{});
  sys_mod.unblock_cmd_stream();
}

comptime {
  // When exit_task_id is activated, exit_task will execute
  @bind_local_task(exit_task, exit_task_id);
  @bind_local_task(receive_east_task, receive_east_task_id);
  @bind_local_task(receive_west_task, receive_west_task_id);
  @bind_local_task(receive_north_task, receive_north_task_id);
  @bind_local_task(receive_south_task, receive_south_task_id);

  @bind_local_task(send_west_task, send_west_task_id);
  @bind_local_task(send_east_task, send_east_task_id);
  @bind_local_task(send_north_task, send_north_task_id);
  @bind_local_task(send_south_task, send_south_task_id);

  @bind_local_task(loop_task, loop_task_id);

  // On WSE-3, we must explicitly initialize input and output queues
  if (@is_arch("wse3")) {
    @initialize_queue(send_color_oq_e, .{ .color = send_e_col });
    @initialize_queue(send_color_oq_w, .{ .color = send_w_col });
    @initialize_queue(send_color_oq_n, .{ .color = send_n_col });
    @initialize_queue(send_color_oq_s, .{ .color = send_s_col });

    @initialize_queue(recv_color_iq_e, .{ .color = recv_e_col });
    @initialize_queue(recv_color_iq_w, .{ .color = recv_w_col });
    @initialize_queue(recv_color_iq_n, .{ .color = recv_n_col });
    @initialize_queue(recv_color_iq_s, .{ .color = recv_s_col });
  }else{

    // must also be initialized on WSE-2 manually if using dsrs
    // not documented !!!
    @initialize_queue(recv_color_iq_e, .{ .color = recv_e_col });
    @initialize_queue(recv_color_iq_w, .{ .color = recv_w_col });
    @initialize_queue(recv_color_iq_n, .{ .color = recv_n_col });
    @initialize_queue(recv_color_iq_s, .{ .color = recv_s_col });
  }

  @load_to_dsr(send_north_dsr_dest_5, send_north_dsd, .{ .async=true, .activate=send_north_task });
  @load_to_dsr(send_south_dsr_dest_6, send_south_dsd, .{ .async=true, .activate=send_south_task });
  @load_to_dsr(send_west_dsr_dest_7, send_west_dsd, .{ .async=true, .activate=send_west_task });
  @load_to_dsr(send_east_dsr_dest_8, send_east_dsd, .{ .async=true, .activate=send_east_task });
  @load_to_dsr(recv_north_dsr_src1_9, recv_north_dsd, .{ .async=true, .activate=receive_north_task });
  @load_to_dsr(recv_south_dsr_src1_10, recv_south_dsd, .{ .async=true, .activate=receive_south_task });
  @load_to_dsr(recv_west_dsr_src1_11, recv_west_dsd, .{ .async=true, .activate=receive_west_task });
  @load_to_dsr(recv_east_dsr_src1_12, recv_east_dsd, .{ .async=true, .activate=receive_east_task });

  @load_to_dsr(own_values_send_north_dsr_src1_5, own_values_send_north_dsd);
  @load_to_dsr(own_values_send_south_dsr_src1_6, own_values_send_south_dsd);
  @load_to_dsr(own_values_send_west_dsr_src1_7, own_values_send_west_dsd);
  @load_to_dsr(own_values_send_east_dsr_src1_8, own_values_send_east_dsd);
  @load_to_dsr(buffer_recv_north_dsr_dest_9, buffer_recv_north_dsd);
  @load_to_dsr(buffer_recv_south_dsr_dest_10, buffer_recv_south_dsd);
  @load_to_dsr(buffer_recv_west_dsr_dest_11, buffer_recv_west_dsd);
  @load_to_dsr(buffer_recv_east_dsr_dest_12, buffer_recv_east_dsd);

  @load_to_dsr(own_values_dsr_src0_1, own_values_dsd);
  @load_to_dsr(own_values_dsr_src0_2, own_values_dsd);
  @load_to_dsr(own_values_dsr_src0_3, own_values_dsd);
  @load_to_dsr(own_values_dsr_src0_4, own_values_dsd);
  @load_to_dsr(own_values_dsr_dest_1, own_values_dsd);
  @load_to_dsr(own_values_dsr_dest_2, own_values_dsd);
  @load_to_dsr(own_values_dsr_dest_3, own_values_dsd);
  @load_to_dsr(own_values_dsr_dest_4, own_values_dsd);

  @load_to_dsr(shift_up_dsr_src1_1, up_shift_dsd);
  @load_to_dsr(shift_down_dsr_src1_2, down_shift_dsd);
  @load_to_dsr(shift_left_dsr_src1_3, left_shift_dsd);
  @load_to_dsr(shift_right_dsr_src1_4, right_shift_dsd);

  @load_to_dsr(buffer_center_dsr_dest_13, buffer_center_dsd);
  @load_to_dsr(own_values_dsr_src1_13, own_values_dsd);


  @export_symbol(own_values_ptr, "values");
  @export_symbol(weights_ptr, "weights");
  @export_symbol(compute);
  @export_symbol(buffer_ptr, "buffer");
}